{"instruction": "请根据描述和条件，给结下来输入的编程题提供解法", "input": "编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。\n \n提示：\n\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。\n\n \n示例 1：\n\n输入：n = 00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n\n示例 2：\n\n输入：n = 00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n\n示例 3：\n\n输入：n = 11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n \n提示：\n\n输入必须是长度为 32 的 二进制串 。\n\n\n\n \n进阶：\n\n如果多次调用这个函数，你将如何优化你的算法？\n请使用 JavaScript 语言。\n提示：可以使用lowbit。\n这里提供一个参考思路，`x -= (x & -x)` 可以消除二进制形式的最后一位 1。\n\n同 [剑指 Offer 15. 二进制中 1 的个数](/lcof/面试题15.%20二进制中1的个数/README.md)", "output": "以下是可供参考的实现方案：\n ['```js\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function (n) {\\n    let ans = 0;\\n    while (n) {\\n        n &= n - 1;\\n        ++ans;\\n    }\\n    return ans;\\n};\\n```']", "source": "leetcode_instructions.jsonl"}
{"instruction": "请根据描述的需求和实现思路提示，完成函数开发", "input": "给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。\n \n示例 1:\n\n输入: nums = [2,2,3,4]\n输出: 3\n解释:有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n\n示例 2:\n\n输入: nums = [4,2,3,4]\n输出: 4\n \n提示:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\n请使用 Rust 语言。\n提示：可以使用排序 + 二分查找。\n这里提供一个参考思路，一个有效三角形需要满足：**任意两边之和大于第三边**。即：`a + b > c`①, `a + c > b`②, `b + c > a`③。\n\n如果我们将边按从小到大顺序排列，即 `a < b < c`，那么显然 ②③ 成立，我们只需要确保 ① 也成立，就可以形成一个有效三角形。\n\n我们在 `[0, n - 3]` 范围内枚举 i，在 `[i + 1, n - 2]` 范围内枚举 j，在 `[j + 1, n - 1]` 范围内进行二分查找，找出第一个大于等于 `nums[i] + nums[j]` 的下标 left，那么在 `[j + 1, left - 1]` 范围内的 k 满足条件，将其累加到结果 ans。\n\n时间复杂度：$O(n^2\\log n)$。", "output": "以下是可供参考的实现方案：\n ['```rust\\nimpl Solution {\\n    pub fn triangle_number(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let n = nums.len();\\n        let mut res = 0;\\n        for i in (2..n).rev() {\\n            let mut left = 0;\\n            let mut right = i - 1;\\n            while left < right {\\n                if nums[left] + nums[right] > nums[i] {\\n                    res += right - left;\\n                    right -= 1;\\n                } else {\\n                    left += 1;\\n                }\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```']", "source": "leetcode_instructions.jsonl"}
